% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/gamVineSeqEst.R
\name{gamVineSeqEst}
\alias{gamVineSeqEst}
\title{Sequential maximum penalized likelihood estimation of a GAM-Vine model.}
\usage{
gamVineSeqEst(dataset, GVC, method = "NR", tol.rel = 0.001, n.iters = 10,
  verbose = FALSE)
}
\arguments{
\item{GVC}{\code{\link{gamVine-class}} object.}

\item{method}{\code{'NR'} for Newton-Raphson
and  \code{'FS'} for Fisher-scoring (default).}

\item{tol.rel}{Relative tolerance for \code{'FS'}/\code{'NR'} algorithm.}

\item{n.iters}{Maximal number of iterations for
\code{'FS'}/\code{'NR'} algorithm.}

\item{verbose}{\code{TRUE} if informations should be printed during the
estimation and \code{FALSE} (default) for a silent version.}

\item{data}{A matrix or data frame containing the data in [0,1]^d.}

\item{...}{Additional parameters to be passed to \code{\link{gam}}
from \code{\link[mgcv:mgcv-package]{mgcv}}.}
}
\value{
\code{gamBiCopEst} returns a \code{\link{gamVine-class}} object.
}
\description{
This function estimates the parameter(s) of a Generalized Additive model
(GAM) Vine model, where GAMs for individual edges are specified either for
the copula parameter or Kendall's tau.
It solves the maximum penalized likelihood estimation for the copula families
supported in this package by reformulating each Newton-Raphson iteration as
a generalized ridge regression, which is solved using
the \code{\link[mgcv:mgcv-package]{mgcv}} package.
}
\examples{
require(VineCopula)
set.seed(0)

## A first example with a 3-dimensional GAM-Vine

# Define a R-vine tree structure matrix
d <- 3
Matrix <- c(2,3,1,0,3,1,0,0,1)
Matrix <- matrix(Matrix,d,d)
nnames <- paste("x", 1:d, sep = "")

# Copula families for each edge
fam <- c(3,4,1)

# Parameters for the first tree (two unconditional copulas)
par <- c(1,2)

# A link for the second tree (a unique conditional copula)
g <- function(x){
  tanh(x/2)
}

# Pre-allocate the GAM-Vine model list
count <- 1
model <- vector(mode = "list", length = d*(d-1)/2)

# The first tree contains only the two unconditional copulas
for(i in 1:(d-1))
{
  model[[count]] <- list(family = fam[count], par = par[count], par2 = 0)
  count <- count + 1
}

# The second tree contains a unique conditional copula
# In this first example, we take a linear calibration function (10*x-5)
tmp <- sapply(seq(0,1,1e-3), function(x) BiCopSim(1, fam[count], g(10*x-5)))
data <- data.frame(u1 = tmp[1,], u2 = tmp[2,], x1 = seq(0,1,1e-3))
model[[count]] <- gamBiCopEst(data, ~ x1, fam[count])$res

# Define gamVine object
GVC <- gamVine(Matrix = Matrix, model = model, names = nnames)
summary(GVC)

# Simulate new data
N <- 1e3
simData <- data.frame(gamVineSim(N, GVC))
colnames(simData) <- nnames

# Fit data
summary(fitGVC <- gamVineSeqEst(simData, GVC))

# The second tree contains a unique conditional copula
# In this first example, we take a quadratic calibration function
quad <- function(t, Ti = 0, Tf = 1, b = 8) {
  Tm <- (Tf - Ti)/2
  a <- -(b/3) * (Tf^2 - 3 * Tf * Tm + 3 * Tm^2)
  return(a + b * (t - Tm)^2)}
tmp <- sapply(seq(0,1,1e-3), function(x) BiCopSim(1, fam[count], g(quad(x))))
data <- data.frame(u1 = tmp[1,], u2 = tmp[2,], x1 = seq(0,1,1e-3))
model[[count]] <- gamBiCopEst(data, ~ s(x1, k = 5, fx = T), fam[count])$res

# Update the gamVine object
GVC <- gamVine(Matrix = Matrix, model = model, names = nnames)
summary(GVC)

# Simulate new data
N <- 1e3
simData <- data.frame(gamVineSim(N, GVC))
colnames(simData) <- nnames

# Fit data
summary(fitGVC <- gamVineSeqEst(simData, GVC))
}
\seealso{
\code{\link{gamVine-class}}, \code{\link{gamVineSim}} and
\code{\link{gamBiCopEst}}.
}

