}
model[[count]] <- tmp
count <- count+1
}
}
# Create gamVineCopula object
GVC <- gamVine(Matrix=Matrix,model = model,names=nnames)
print(GVC)
# simulate the gamVineMatrix
N <- 1e3
sim <- gamVineSim(N, GVC)
fitGVC <- gamVineSeqEst(sim, GVC, verbose = TRUE)
#
par(mfrow=c(2,4))
plot(GVC, ylim = c(-2.5,2.5))
plot(fitGVC, ylim = c(-2.5,2.5))
qt(0.05,12)
x <- cbind(0:7,c(8,3,6,10,3,7,2,1))
x
sum(apply(x,2,prod))
sum(apply(x,2,prod))/sum(x[,2])
sum(x[,2])
apply(x,2,prod)
apply(x,1,prod)
sum(apply(x,1,prod))/sum(x[,2])
cumsum(x[,2])/sum(x[,2])
0.675-0.275
1/0.4
(0.5-0.275)/0.4
(0.5-0.425)/(0.675-0.425)
length(cumsum(x[,2])/sum(x[,2]))
?choose
choose(30,3)
choose(30,3)*3*2
choose(30,2)*3*2
choose(29,2)*3*2
choose(12,1)
12*18*choose(28,1)
18*choose(29,2)*2
12*choose(29,2)*2
0.4*0.01/0.008
1-0.01-0.08+0.4*0.01
0.01*0.6+0.08*0.5
0.01*0.6+0.008*0.5
ppois(7,6)
1-ppois(7,6)
dpois(7,1.5)
dpois(2:4,1.5)
sum(dpois(2:4,1.5))
?dpois
dpois(3,1.5)
dpois(4,1.5)
ppois(4,1.5)
ppois(3.5,1.5)
ppois(3,1.5)
0.5^3-0.3^3
(0.5^3-0.3^3)/(0.5^3-0.2^3)
pnorm(0.2,0,0.1)
pnorm(0.2,0,0.1)-pnorm(-0.2,0,0.1)
1-(pnorm(0.2,0,0.1)-pnorm(-0.2,0,0.1))
pnorm(2.5,0,0.1)
n*0.1^2
10*0.1^2
sqrt(0.1)
pnorm(2.5,0,sqrt(0.1))
(0.05/1.96)^2*100
1-(0.05/1.96)^2*100
sqrt(1-(0.05/1.96)^2*100)
1-sqrt(1-(0.05/1.96)^2*100)
(1-sqrt(1-(0.05/1.96)^2*100))/2
(1+sqrt(1-(0.05/1.96)^2*100))/2
(0.05/1.96)^2*100
x <- 0.45
x*(1-x)
x <- 0.73
x*(1-x)
x <- 0.93
x*(1-x)
x <- 0.07
x*(1-x)
169+1.96*qnorm(0.975,0,5)
169+qnorm(0.975,0,5)
169+1.96*5
169+1.96*5/4
169+qnorm(0.95)
qnorm(0.95)
0.72+qnorm(0.95)*sqrt(0.72*(1-0.72)/100)
x <- c(81,51,41)
m <- c(3.41,2.97,2.78)
sum(x*m)/sum(x)
1.73/sum(x)
(sum(x*m)/sum(x) - 3)/sqrt(1.73/sum(x))
(2.97-2.98)/sqrt(1.65/51+1.62/41)
(2.97-2.78)/sqrt(1.65/51+1.62/41)
(1.65/51+1.62/41)
(1.65/51+1.62/41)^2/((1.65/51)^2*1/50+(62/41)^2*1/40)
(1.65/51+1.62/41)^2
(1.65/51)^2$
a
(1.65/51)^2/50
(1.65/51)^2/50+(62/41)^2/40
(1.65/51+1.62/41)^2/((1.65/51)^2/50+(62/41)^2/40)
library(VineCopula)
?ktaumatrix
# Gaussian and Clayton copulas
n <- 500
tau <- 0.5
# simulate from Gaussian copula
fam1 <- 1
theta1 <- BiCopTau2Par(fam1, tau)
set.seed(123)
dat1 <- BiCopSim(n, fam1, theta1)
# simulate from Clayton copula
fam2 <- 3
theta2 <- BiCopTau2Par(fam2, tau)
set.seed(123)
dat2 <- BiCopSim(n, fam2, theta2)
# create K-plots
par(mfrow=c(1,2))
BiCopKPlot(dat1[,1], dat1[,2], main = "Gaussian copula")
BiCopKPlot(dat2[,1], dat2[,2], main = "Clayton copula")
?TauMatrix
?TauMatrix
library(gamCopula)
?gamVineSim
require(VineCopula)
## Example adapted from RVineSim
## Define 5-dimensional R-vine tree structure matrix
Matrix <- c(5, 2, 3, 1, 4,
0, 2, 3, 4, 1,
0, 0, 3, 4, 1,
0, 0, 0, 4, 1,
0, 0, 0, 0, 1)
Matrix <- matrix(Matrix, 5, 5)
## Define R-vine pair-copula family matrix
family <- c(0, 1, 3, 4, 4,
0, 0, 3, 4, 1,
0, 0, 0, 4, 1,
0, 0, 0, 0, 3,
0, 0, 0, 0, 0)
family <- matrix(family, 5, 5)
## Define R-vine pair-copula parameter matrix
par <- c(0, 0.2, 0.9, 1.5, 3.9,
0, 0, 1.1, 1.6, 0.9,
0, 0, 0, 1.9, 0.5,
0, 0, 0, 0, 4.8,
0, 0, 0, 0, 0)
par <- matrix(par, 5, 5)
## Define second R-vine pair-copula parameter matrix
par2 <- matrix(0, 5, 5)
## Define RVineMatrix object
RVM <- RVineMatrix(Matrix = Matrix, family = family,
par = par, par2 = par2,
names = c("V1", "V2", "V3", "V4", "V5"))
## Convert to gamVine object
GVC <- RVM2GVC(RVM)
## U[0,1] random variates to be transformed to the copula sample
n <- 1e2
d <- 5
U <- matrix(runif(n*d), nrow = n)
## The output of gamVineSim correspond to that of RVineSim
sampleRVM <- RVineSim(n,RVM,U)
sampleGVC <- gamVineSim(n,GVC,U)
tmp <- sapply(1:N, function(x)
.C("Hinv1", as.integer(fam[k, i]), as.integer(1),
as.double(Vdirect[k + 1, i, x]), as.double(zz[x]), as.double(par[x]),
as.double(par2), as.double(tmp[x]), PACKAGE = "VineCopula")[[7]])
?BiCopHfunc
x <- 1
Vdirect[k + 1, i, x]
tmp2 <- sapply(1:N, function(x) BiCopHfun(Vdirect[k + 1, i, x], zz[x],
fam[k, i], par[x], par2))
tmp2 <- sapply(1:N, function(x) BiCopHfunc(Vdirect[k + 1, i, x], zz[x],
fam[k, i], par[x], par2))
head(tmp2)
head(t(tmp2))
head(tmp)
dim(tmp2)
par2
tmp <- sapply(1:N, function(x)
.C("Hinv1", as.integer(fam[k, i]), as.integer(1),
as.double(Vdirect[k + 1, i, x]), as.double(zz[x]), as.double(par[x]),
as.double(par2), as.double(tmp[x]), PACKAGE = "VineCopula")[[7]])
tmp2 <- sapply(1:N, function(x) BiCopHfunc(Vdirect[k + 1, i, x], zz[x],
fam[k, i], par[x], par2))
head(t(tmp2))
head(tmp)
library(gamCopula)
library(gamCopula)
?logLik.gamBiCop
?nobs.gamBiCop
library(gamCopula)
?nobs.gamBiCop
?logLik.gamBiCop
library(gamCopula)
?logLik.gamBiCop
?gamBiCop
?logLik
?formula
?gamBiCop
?gamBiCop-class
?gamBiCop-class
?formula
?lm
ctl <- c(4.17,5.58,5.18,6.11,4.50,4.61,5.17,4.53,5.33,5.14)
trt <- c(4.81,4.17,4.41,3.59,5.87,3.83,6.03,4.89,4.32,4.69)
group <- gl(2, 10, 20, labels = c("Ctl","Trt"))
weight <- c(ctl, trt)
lm.D9 <- lm(weight ~ group)
formula(lm.D9)
?gam
?gamBiCop
library(gamCopula)
?gamBiCop
library(gamCopula)
?gamObject
?gamBiCop-class
library(gamCopula)
?gamBiCop-class
?gamBiCop
?formula
?nobs
?logLik
?BIC
library(gamCopula)
?AIC.gamBiCop
?dim
library(gamCopula)
library(VineCopula)
?BiCopPar2Tau
BiCopPar2Tau
f1 <- function(x) tanh(x/2)
f2 <- function(x) exp(x)
f3 <- function(x) 1 + f2(x)
f4 <- function(x) (tanh(x/2)+1)/2
f5 <- function(x) 2 + f2(x)
f2r <- function(x) -f2(-x)
f3r <- function(x) -f3(-x)
f4r <- function(x) -f4(-x)
id <- function(x) x
x <- seq(-5,5,1e-2)
plot(x,f1(x))
plot(x,f2(x))
plot(x,f3(x))
plot(x,f4(x))
plot(x,f5(x))
plot(x,f4(x))
plot(x,f5(x))
plot(x,f2e(x))
plot(x,f2r(x))
plot(x,f2r(-x))
?BiCopTau2Par
?BiCopPar2Tau
library(gamCopula)
library(gamCopula)
bla <- matrix(12,4,3)
is.numeric(bla)
is.logical(NA)
library(gamCopula)
?condBiCopSim
bla <- list(function(x) x, matrix(12,4,3))
bla
as.data.frame(bla)
?try
try(as.data.frame(bla))
try(as.data.frame(bla), TRUE)
tryCatch(as.data.frame(bla), error = function(e) e)
bla <- tryCatch(as.data.frame(bla), error = function(e) e)
names(bla)
bla["message"]
class(bla)
is.list(bla)
bla[[1]]
bla <- tryCatch(as.data.frame(bla), error = function(e) capture.output(e))
bla
bla <- tryCatch(as.data.frame(bla), error = function(e) e)
geterrmessage
geterrmessage(bla)
bla
bla <- list(function(x) x, matrix(12,4,3))
test <- tryCatch(as.data.frame(bla), error = function(e) capture.output(e))
test
test <- tryCatch(as.data.frame(bla), error = function(e) e)
test
test
names(test)
test$message
cat(test$message)
capture.output(cat(test$message))
tryCatch(as.data.frame(bla), error = function(e) e)
tryCatch(as.data.frame(bla), error = function(e) e$message)
data <- bla
tt(data <- as.data.frame(data[-which(names(data) == "xt")]))
tt <- function(t) tryCatch(as.data.frame(t), error = function(e) e$message)
tt(data <- as.data.frame(data[-which(names(data) == "xt")]))
data
tt
tt(data)
data <- bla
tt(data)
tryCatch(data <- as.data.frame(data), error = function(e) e$message)
data
data <- data[[2]]
tryCatch(data <- as.data.frame(data), error = function(e) e$message)
data
tmp <- tryCatch(data <- as.data.frame(data), error = function(e) e$message)
tmp
data <- bla
tmp <- tryCatch(data <- as.data.frame(data), error = function(e) e$message)
tmp
data <- tryCatch(as.data.frame(data), error = function(e) e$message)
data
data <- bla
data <- tryCatch(as.data.frame(data), error = function(e) e$message)
data
bla
data <- bla[[2]]
data <- tryCatch(as.data.frame(data), error = function(e) e$message)
data
data <- bla
data <- tryCatch(as.data.frame(data), error = function(e) e$message)
data
is.character(data)
is.integer(1)
is.integer(as.integer(1))
is.numeric(as.integer(1))
1==FALSE
1==TRUE
RVineSim
is.na(NULL)
matrix(12,4,3)
U <-matrix(12,4,3)
is.na(U)
U[1]
U[1] <- NA
is.numeric(U)
U
if ( 1 == 2 ) { print("bla")} else if (1 == 1) {print("blabla")}
library(gamCopula)
?gamVineStructureSelect
require(VineCopula)
set.seed(0)
## A first example with a 3-dimensional GAM-Vine
# Define a R-vine tree structure matrix
d <- 3
Matrix <- c(2,3,1,0,3,1,0,0,1)
Matrix <- matrix(Matrix,d,d)
nnames <- paste("x", 1:d, sep = "")
# Copula families for each edge
fam <- c(3,4,1)
# Parameters for the first tree (two unconditional copulas)
par <- c(1,2)
# Pre-allocate the GAM-Vine model list
count <- 1
model <- vector(mode = "list", length = d*(d-1)/2)
# The first tree contains only the two unconditional copulas
for (i in 1:(d-1)) {
model[[count]] <- list(family = fam[count], par = par[count], par2 = 0)
count <- count + 1
}
# The second tree contains a unique conditional copula
# In this first example, we take a linear calibration function (10*x-5)
# Set-up a dummy dataset
tmp <- data.frame(u1 = runif(1e2), u2 = runif(1e2), x1 = runif(1e2))
# Set-up an arbitrary linear model for the calibration function
model[[count]] <- gamBiCopEst(tmp, ~ x1, fam[count])$res
# Update the coefficients of the model
attr(model[[count]],"model")$coefficients <- c(-5, 10)
# Define gamVine object
GVC <- gamVine(Matrix = Matrix, model = model, names = nnames)
GVC
# Simulate new data
N <- 1e3
simData <- data.frame(gamVineSim(N, GVC))
colnames(simData) <- nnames
gamBiCopEst(tmp, ~ x1, fam[count])
tmp
require(VineCopula)
set.seed(0)
## A first example with a 3-dimensional GAM-Vine
# Define a R-vine tree structure matrix
d <- 3
Matrix <- c(2,3,1,0,3,1,0,0,1)
Matrix <- matrix(Matrix,d,d)
nnames <- paste("x", 1:d, sep = "")
# Copula families for each edge
fam <- c(3,4,1)
# Parameters for the first tree (two unconditional copulas)
par <- c(1,2)
# Pre-allocate the GAM-Vine model list
count <- 1
model <- vector(mode = "list", length = d*(d-1)/2)
# The first tree contains only the two unconditional copulas
for (i in 1:(d-1)) {
model[[count]] <- list(family = fam[count], par = par[count], par2 = 0)
count <- count + 1
}
# The second tree contains a unique conditional copula
# In this first example, we take a linear calibration function (10*x-5)
# Set-up a dummy dataset
tmp <- data.frame(u1 = runif(1e2), u2 = runif(1e2), x1 = runif(1e2))
# Set-up an arbitrary linear model for the calibration function
model[[count]] <- gamBiCopEst(tmp, ~ x1, fam[count])$res
# Update the coefficients of the model
attr(model[[count]],"model")$coefficients <- c(-5, 10)
# Define gamVine object
GVC <- gamVine(Matrix = Matrix, model = model, names = nnames)
GVC
# Simulate new data
N <- 1e3
simData <- data.frame(gamVineSim(N, GVC))
colnames(simData) <- nnames
library(gamCopula)
library(gamCopula)
simData <- data.frame(gamVineSim(N, GVC))
chk
simData <- data.frame(gamVineSim(N, GVC))
library(gamCopula)
summary(fitGVC <- gamVineSeqEst(simData, GVC))
summary(fitGVC2 <- gamVineStructureSelect(simData))
?BiCopSelect
install.packages("VineCopula")
install.packages("VineCopula")
install.packages("VineCopula")
install.packages("VineCopula")
install.packages("VineCopula")
library(gamCopula)
?gamVineStructureSelect
require(VineCopula)
set.seed(0)
## A first example with a 3-dimensional GAM-Vine
# Define a R-vine tree structure matrix
d <- 3
Matrix <- c(2,3,1,0,3,1,0,0,1)
Matrix <- matrix(Matrix,d,d)
nnames <- paste("x", 1:d, sep = "")
# Copula families for each edge
fam <- c(3,4,1)
# Parameters for the first tree (two unconditional copulas)
par <- c(1,2)
# Pre-allocate the GAM-Vine model list
count <- 1
model <- vector(mode = "list", length = d*(d-1)/2)
# The first tree contains only the two unconditional copulas
for (i in 1:(d-1)) {
model[[count]] <- list(family = fam[count], par = par[count], par2 = 0)
count <- count + 1
}
# The second tree contains a unique conditional copula
# In this first example, we take a linear calibration function (10*x-5)
# Set-up a dummy dataset
tmp <- data.frame(u1 = runif(1e2), u2 = runif(1e2), x1 = runif(1e2))
# Set-up an arbitrary linear model for the calibration function
model[[count]] <- gamBiCopEst(tmp, ~ x1, fam[count])$res
# Update the coefficients of the model
attr(model[[count]],"model")$coefficients <- c(-5, 10)
# Define gamVine object
GVC <- gamVine(Matrix = Matrix, model = model, names = nnames)
GVC
# Simulate new data
N <- 1e3
simData <- data.frame(gamVineSim(N, GVC))
colnames(simData) <- nnames
# Fit data
summary(fitGVC <- gamVineSeqEst(simData, GVC))
summary(fitGVC2 <- gamVineStructureSelect(simData))
library(gamCopula)
require(VineCopula)
set.seed(0)
## A first example with a 3-dimensional GAM-Vine
# Define a R-vine tree structure matrix
d <- 3
Matrix <- c(2,3,1,0,3,1,0,0,1)
Matrix <- matrix(Matrix,d,d)
nnames <- paste("x", 1:d, sep = "")
# Copula families for each edge
fam <- c(3,4,1)
# Parameters for the first tree (two unconditional copulas)
par <- c(1,2)
# Pre-allocate the GAM-Vine model list
count <- 1
model <- vector(mode = "list", length = d*(d-1)/2)
# The first tree contains only the two unconditional copulas
for (i in 1:(d-1)) {
model[[count]] <- list(family = fam[count], par = par[count], par2 = 0)
count <- count + 1
}
# The second tree contains a unique conditional copula
# In this first example, we take a linear calibration function (10*x-5)
# Set-up a dummy dataset
tmp <- data.frame(u1 = runif(1e2), u2 = runif(1e2), x1 = runif(1e2))
# Set-up an arbitrary linear model for the calibration function
model[[count]] <- gamBiCopEst(tmp, ~ x1, fam[count])$res
# Update the coefficients of the model
attr(model[[count]],"model")$coefficients <- c(-5, 10)
# Define gamVine object
GVC <- gamVine(Matrix = Matrix, model = model, names = nnames)
GVC
# Simulate new data
N <- 1e3
simData <- data.frame(gamVineSim(N, GVC))
colnames(simData) <- nnames
# Fit data
summary(fitGVC <- gamVineSeqEst(simData, GVC))
summary(fitGVC2 <- gamVineStructureSelect(simData))
library(gamCopula)
summary(fitGVC2 <- gamVineStructureSelect(simData))
fitGVC2
library(gamCopula)
summary(fitGVC2 <- gamVineStructureSelect(simData))
tmp
plot(tmp$res)
